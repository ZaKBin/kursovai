:description: Курсовой проект
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: images
:important-caption: ВАЖНО!
:note-caption: ЗАМЕЧАНИЕ
:stem:

== Требования к разработке проекта

В данном проекте необходимо измерять напряжение с потенциометра и, используя значение напряжения, управлять ярокстью светодиода за счёт модуля PWM.

.Требования к курсовому проекту
|===
|Параметр/характеристика |Требование

|Отладочная плата
|XNUCLEO-F411RE

|Объект и характеристика для измерения
|Напряжение с потенциометра, установленного на плате расширения Accessories Shield

|Способ измерения напряжения
|Встроенный АЦП

|Период измерения
|50 мс

|Способ получения кода
|Механизм DMA

|Точность измерения
|Не менее 0,01 В

|Способ передачи значений
|По беспроводному интерфейсу через модуль BlueTooth Bee HC-06 или I/O Expansion Shield

|Способ общения с платой расширения
|USART2

|Архитектура
|В виде UML диаграммы

|Требование к приложению
|Язык C++ с использованием компилятора ARM 8.40.2 и использование FreeRTOS
|===

К измеренному напряжению должен быть применен цифровой фильтр вида:

stem:["tau" = int ((1-e^(-"dt"/("R"*"C")), "RC" > 0 sec), (1, RC = 0 sec));] 

stem:["FilteredValue" = "OldValue" + ("Valu"e" - "OldValue") * "tau"] ,


где stem:["dt"] - 100 мс; +
stem:[Value] – текущее нефильтрованное измеренное значение напряжения; +
stem:[OldValue] - предыдущее фильтрованное значение.

Для управления яркостью светодиода должен использоваться модуль PWM. Светодиод находится на порту PortC.8.

Формат вывода: +
"Напряжение: " X.XXX [V].

== Анализ требований к ПО

=== Отладочная плата XNUCLEO-F411RE и плата расширения Accessory Shield

Отладочная плаата XNUCLEO-F411RE - это улучшенная версия отладочной платы STM32 Nucleo, созданная компанией Waveshare. Основана XNUCLEO-F411RE на микроконтроллере STM32F411RET6 с ядром ARM Cortex-4 и предназначена для создания проектов и прототипирования. 

.Отладочная плата XNUCLEO-F411RE
image::XNUCLEO-F411RE.jpg[]

Основные особенности платы XNUCLEO-F411RE:

* совместимость с Arduino;
* подключение по USB;
* наличие светодиодов и пользовательской кнопки.

В ходе выполнения курсового проекта используется плата расширения Accessory Shield.

.Плата расширения Accessory Shield
image::accessory_shield.jpg[]

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. На плате установлены самые популярные дочерние модули, подходящие для реализации большинства задач.

Особенности платы расширения:

* разъем для подключения плат Arduino;
* разъем XBee для подключения беспроводных модулей;
* OLED дисплей 0,96 дюймов с разрешением 128x64 пикселей;
* RGB-светодиод;
* зуммер;
* потенциометр 10 кОм;
* 3-осевой цифровой акселерометр ADXL345;
* температурный датчик LM75BDP,
* джойстик 5-ти позиционный,
* индикатор состояния XBee,
* индикатор питания,
* кнопка сброса модулей XBee и Arduino,
* часы реального времени (RTC),
* держатель батареи CR1220 для RTC,
* драйвер RGB светодиода,
* джампер выбора режима Отладка/Связь.

=== Софт должен измерять напряжение с переменного резистора, установленного на плате расширения

Переменный резистор, установленный на плате расширения, согласно спецификации Waveshare, подключен к аналоговому входу микроконтроллера, пин *PA0*.

.Распиновка XNUCLEO-F411RE
image::xnucleo_spec.jpg[]

В плате расширения используется линейный потенциометр с тремя выводами:

* один крайний вывод подключен в питанию 3,3 В (стандартное напряжение питания);
* другой крайний вывод подключен к земле;
* центральный вывод выведен на аналоговый вход микроконтроллера (пин PA0).

Таким образом, при вращении ручки потенциометра напряжение на центральном выводе изменяется от 0 В до 3,3 В.

Поскольку напряжение - аналоговый сигнал, его нужно измерять с помощью аналого-цифрового преобразователя (АЦП).

=== Для измерения напряжения должен использоваться встроенный АЦП с использованием DMA

Микроконтроллер STM32F411RET6 оснащен 12-битным АЦП, поддерживающим 19 каналов и позволяющим имзерять сигналы из 16 внешних источников, 2 внутренних источников, а также канал VBAT (измерение напряжения на линии питания резервной батареи).

Аналого-цифровое преобразование каналов может осуществляться в следующих режимах:

* Single Mode (однократное преобразование) - для выбранного канала преобразование выполняется один раз и останавливается после завершения.
* Continuous Mode (непрерывное преобразование) - автоматическое повторение преобразования выбранного канала без необходимости повторного запуска.
* Scan Mode (режим сканирования) - АЦП выполняет преобразование для группы каналов, заданных в последовательности, по одному за раз. Этот режим не является самостоятельным, а комбинируется с Single или Continuous.
* Discontinuous Mode (Прерывистый режим) - улучшенный режим  сканирования. Разбивает последовательность каналов на подгруппы. АЦП выполняет преобразование заданного числа каналов за один цикл, затем останавливается до следующего триггера.

Поскольку, <<DMA, согласно требованиям к ПО>>, требуется использовать механизм DMA совместно с АЦП, следует использовать режим непрерывного преобразования. АЦП будет передавать считанные значения с помощью DMA автоматически по выбранному адресу, без использования ядра процессора.

Для того, чтобы настроить АЦП в режиме непрерывного преобразования, нужно:

. подать тактирование на порт, который будет использоваться для считывания данных с АЦП;
. настроить порт, подключенный к нужному каналу АЦП, на аналоговый вход;
. подать тактирование на АЦП;
. настроить разрешение АЦП;
. настроить режим преобразования (регистр ADC_CR2);
. выбрать нужный канал для измерения;
. настроить канал АЦП на необходимую частоту преобразования;
. включить АЦП;
. начать преобразование;
. дождаться флага готовности преобразования;
. считать преобразованное значение.

В <<table_ADC, данной таблице>> показаны настройки регистров, необходимых для включения АЦП в режиме непрерывного преобразования.

Счеты АЦП должны преобразовываться в напряжение по следующей формуле (для 12-битного АЦП): 

[%center]
[latexmath]
++++
V_{ADC} = \frac{ADC_{counts} \cdot V_{ref}}{4096},
++++

где latexmath:[ADC_{counts}] - текущие счеты АЦП; +
latexmath:[V_{ref} = 3,3 V] - опорное напряжение.

<<DMA, Согласно требованиям к ПО>>, для получения кода измерения должен использоваться механизм DMA. DMA - это режим обмена данными между периферией и основной памятью, в котором центральный процессор не участвует. Для работы с DMA в микроконтроллер встроены специальные контроллеры DMA.

На микроконтроллере STM32F411RET6 имеется 2 контроллера DMA, каждый из которых имеет 8 каналов, каждый канал имеет 8 потоков, которые подключаются к конкретному периферийному устройству. Если установлен бит DMA регистра ADC_CR2, то по окончании преобразования АЦП генерирует запрос DMA. Контроллер DMA получит этот запрос по внутренней линии связи между периферией и DMA. Затем контроллер DMA считывает данные с АЦП (записанные в регистр ADC_DR) и записывает их в указанный адрес памяти.

В спецификации к микроконтроллеру имеется таблица запросов DMA.

.Таблица запросов DMA
image::DMA_Requests_Tables.png[]

Согласно этой таблице, для того, чтобы генерировать запросы от АЦП, следует использовать контроллер DMA2, канал 0, потоки 0 или 4. В данной работе используется поток 0.

В <<table_DMA, данной таблице>> показана конфигурация регистров DMA для данного проекта.

Алгоритм настройки потока DMA представлен в пункте 9.3.17 в https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf[Reference Manual] к STM32F411RET6.

=== Индикация измеренного напряжения светодиодами

Для управления яркостью светодиода в проекте используется модуль широтно-импульсной модуляции (ШИМ, PWM) на базе таймера TIM3 микроконтроллера STM32F411RET6. В соответствии с Datasheet - STM32F411xC был взят TIM3. ШИМ позволяет изменять яркость светодиода за счет регулировки скважности импульсов, подаваемых на порт PortC.8, к которому подключен светодиод. Значение яркости определяется измеренным напряжением с потенциометра, преобразованным в соответствующее значение для регистра сравнения TIM3_CCR3.

.Выбор таймера
image::TIM3_CH3.png[]

==== Принципы работы ШИМ
ШИМ в STM32F411RET6 реализуется с использованием таймеров, которые генерируют периодический сигнал с изменяемой шириной импульса. Таймер TIM3, используемый в проекте, работает в режиме ШИМ, где:

* Период сигнала задается значением регистра авто-перезагрузки TIM3_ARR.

* Ширина импульса определяется значением регистра сравнения TIM3_CCR3.

* Скважность (duty cycle) вычисляется как отношение значения TIM3_CCR3 к значению TIM3_ARR+1, умноженное на 100%.

Полная математическая модель, показывающую, как входное напряжение Vin управляет яркостью светодиода ( L ).

* Измерение напряжения с помощью АЦП

Входное напряжение latexmath:[V_{in}] с потенциометра преобразуется в цифровой код latexmath:[ADC_{code}] через АЦП. Процесс описывается уравнением:

[%center]
[latexmath]
++++
ADC_{\text{code}} = \left\lfloor \frac{V_{\text{in}}}{V_{\text{ref}}} \times 2^n \right\rfloor
++++

где latexmath:[V_{\text{ref}}=3.3 В] - опорное напряжение АЦП,; +
latexmath:[n=12] - разрядность АЦП (максимальное значение latexmath:[2^{12}=4096]).

Затем цифровой код преобразуется обратно в измеренное напряжениеlatexmath:[V_{meas}] с учетом калибровочных параметров:

[%center]
[latexmath]
++++
V_{\text{meas}} = k \cdot ADC_{\text{code}} + \text{offset}
++++

где latexmath:[k= 0.000806 В/единиц] и latexmath:[offset = 0 В] - коэффициенты, обеспечивающие точность измерений.


* Фильтрация данных:

Для сглаживания измеренного напряжения используется экспоненциальный фильтр нижних частот. В дискретной форме фильтр выражается разностным уравнением:

[%center]
[latexmath]
++++
V_{\text{filtered}}[k] = V_{\text{filtered}}[k-1] + \tau \cdot \left( V_{\text{meas}}[k] - V_{\text{filtered}}[k-1] \right)
++++

где latexmath:[V_{\text{filtered}}[k]] - отфильтрованное напряжение на шаге ( k ); +
latexmath:[V_{\text{meas}}[k]] - измеренное напряжение на шаге ( k ); +
latexmath:[\tau = 1-e^{- dt/rc}] - коэффициент сглаживания; +
latexmath:[dt = 0.1с] - шаг дискретизации; +
latexmath:[rc = 10.0с] - постоянная времени фильтра.

* Управление ШИМ:

Отфильтрованное напряжение latexmath:[V_{filtered}] используется для вычисления коэффициента заполнения ( kz ), который определяет длительность импульса ШИМ:

[%center]
[latexmath]
++++
V_{\text{filtered}}[k] = \sqrt{\frac{1}{T} \int_{0}^{kz[k] \cdot T} V_{\text{max}}^2 \, dt}=  V_{\text{max}} \cdot ( \sqrt{ kz[k]})
++++

[%center]
[latexmath]
++++
kz[k] = \left( \frac{V_{\text{filtered}}[k]}{V_{\text{max}}} \right)^2


++++

где latexmath:[V_{max}= 3.3B] - максимальное напряжение, соответствующее полной яркости. Значение ( kz ) (в диапазоне от 0 до 1) затем преобразуется в значение регистра сравнения ШИМ (CCR):

[%center]
[latexmath]
++++
\text{CCR}[k] = kz[k] \cdot \text{ARR}
++++
где latexmath:[ARR = 2000]- период ШИМ в единицах регистра.

* Яркость светодиода:

Яркость светодиода ( L ) пропорциональна коэффициенту заполнения ( kz ). Предполагая линейную зависимость, получаем:

[%center]
[latexmath]
++++
L[k] = L_{\text{max}} \cdot kz[k] = L_{\text{max}} \cdot \left( \frac{V_{\text{filtered}}[k]}{V_{\text{max}}} \right)^2
++++

где latexmath:[L_{max}] - максимальная яркость светодиода при latexmath:[kz = 1]

==== Режимы работы таймера TIM3

Таймер TIM3 поддерживает несколько режимов работы, включая:

* Up-counting mode (счет вверх):счетчик увеличивается от 0 до значения TIM3_ARR, затем сбрасывается.
* Down-counting mode (счет вниз): счетчик уменьшается от TIM3_ARR до 0.
* Center-aligned mode (центрированный): счетчик считает вверх, затем вниз, создавая симметричный сигнал.
* PWM Mode 1: при счете вверх сигнал высокий, пока счетчик меньше TIM3_CCRx, затем низкий.
* PWM Mode 2: противоположная логика PWM Mode 1.

==== Настройка таймера TIM3 для ШИМ

Для настройки таймера TIM3 в режиме ШИМ необходимо выполнить следующие шаги:

. Подать тактирование на таймер TIM3 через регистр RCC_APB1ENR.
. Настроить порт GPIOC (PortC.8) в режим альтернативной функции для вывода ШИМ-сигнала.
. Установить режим работы таймера (счет вверх, предделитель, значение авто-перезагрузки).
. Настроить канал таймера (в данном случае канал 3) для работы в режиме ШИМ.
. Активировать выход канала и включить таймер.
. Настроить значение регистра TIM3_ARR для задания периода ШИМ-сигнала.

В таблице ниже приведены настройки регистров для включения ШИМ на таймере TIM3.

|===
|Регистр| Поле (номера битов)| Значение| Назначение
|RCC_AHB1ENR| GPIOCEN (2)| 1 |Подать тактирование на порт GPIOC
|GPIOC_MODER|MODER8 (17:16)|10|Установить PortC.8 в режим альтернативной 
|GPIOC_AFRH|AFRH8 (3:0)|0010 (AF2)|Назначить альтернативную функцию AF2 (TIM3_CH3) для PortC.8
|RCC_APB1ENR|TIM3EN (1)|1|Подать тактирование на таймер TIM3
|TIM3_CR1|DIR (4)|0|Установить режим счета вверх
|TIM3_CR1|ARPE (7)|1|Включить буферизацию регистра TIM3_ARR
|TIM3_ARR|ARR (15:0)|2000|Установить период ШИМ (значение регистра авто-перезагрузки)
|TIM3_CCMR2|CC3S (1:0)|00|Установить канал 3 как выход
|TIM3_CCMR2|OC3M (6:4)|110|Установить режим PWM Mode 1 для канала 3
|TIM3_CCMR2|OC3PE (3)|1|Включить буферизацию регистра TIM3_CCR3
|TIM3_CCER|CC3E (8)|1|Активировать выход канала 3
|TIM3_CCER|CC3P (9)|0|Установить полярность канала 3 (активный уровень — высокий)
|TIM3_CCR3|CCR3 (15:0)|Переменное|Установить ширину импульса (зависит от измеренного напряжения)
|TIM3_CR1|CEN (0)|1|Включить таймер TIM3
|===

Буферизация регистра TIM3_ARR, включенная с помощью бита ARPE = 1, обеспечивает синхронизированное и безопасное обновление периода ШИМ-сигнала, предотвращая искажения в случае изменения TIM3_ARR во время работы таймера. В проекте это гарантирует стабильность ШИМ-сигнала для управления яркостью светодиода, даже если текущая реализация не изменяет TIM3_ARR динамически. Включение буферизации является стандартной практикой для повышения надежности и универсальности кода, особенно в приложениях, где важна точность временных характеристик.

Регистр TIM3_ARR определяет период ШИМ-сигнала. Значение TIM3_ARR задает максимальное значение, до которого считает таймер, после чего счетчик сбрасывается. Период сигнала рассчитывается по формуле:

[%center]
[latexmath]
++++
T_{PWM} = \frac{(TIM3_{ARR} + 1) \cdot (PSC + 1)}{f_{TIM}},
++++

где latexmath:[TIM3_{ARR}] - значение регистра авто-перезагрузки; +
latexmath:[PSC] - значение предделителя таймера (TIM3_PSC); +
latexmath:[f_{TIM}] - частота тактирования таймера (обычно равна частоте шины APB1, например, 16 МГц при системной частоте 16 МГц).

В проекте значение TIM3_ARR установлено равным 2000, а предделитель (TIM3_PSC) равен 0 (без деления частоты). При частоте таймера latexmath:[f_{TIM}=16 МГц]:

[%center]
[latexmath]
++++
T_{PWM} = \frac{(2000 + 1) \cdot (0 + 1)}{16\cdot 10^6}=0.000125 с =125μс,
++++

[%center]
[latexmath]
++++
f_{PWM} = \frac{1}{T_{PWM}} = 8 кГц,
++++

Частота ШИМ в 8 кГц выбрана для обеспечения плавного управления яркостью светодиода без заметного мерцания, так как частота значительно превышает порог восприятия человеческого глаза (~100 Гц).

Значение TIM3_ARR = 2000 обеспечивает достаточное разрешение для регулировки скважности (2001 уровень), что позволяет точно управлять яркостью светодиода в зависимости от входного напряжения. Увеличение TIM3_ARR повышает разрешение, но снижает частоту ШИМ, а уменьшение — наоборот. Значение 2000 является компромиссом между разрешением и частотой.

=== Периодичность измерений 50 мс с использованием операционной системы реального времени FreeRTOS

Поскольку, <<period, согласно требованиям к ПО>>, измерения необходимо производить с заданной периодичностью (50 мс), целесообразно использовать операционную систему реального времени.

Операционная система реального времени (ОСРВ) — это ОС, которая предназначена для обработки данных и выполнения задач в строго заданные временные рамки. Она гарантирует, что критически важные процессы завершатся вовремя, минимизируя задержки.

<<RTOS, Согласно требованиям к ПО>>, должна использоваться операционная система реального времени FreeRTOS и обертка над ней. *FreeRTOS* — это компактная операционная система реального времени (ОСРВ) с открытым исходным кодом, предназначенная для встраиваемых систем и микроконтроллеров. Она предоставляет базовые функции для управления задачами, планирования, синхронизации (семафоры, мьютексы, очереди) и работы с ограниченными ресурсами. Под *оберткой* понимается программный слой или библиотека, которая упрощает взаимодействие с FreeRTOS, скрывая её низкоуровневые детали и упрощая разработку.

Так как АЦП и DMA после настройки работают независимо от ядра микроконтроллера, создавать задачу для организации передачи данных между ними не нужно.

В данной таблице представлены задачи, которые выполняются операционной системой реального времени.

[cols="^,^,^,^,^"]
.Задачи, выполняемые операционной системой реального времени
|===
| Задача | Описание | Периодичность | Приоритет | Взаимодействие
| [[task1]] Расчет считанного значения напряжения, переданного по DMA | Читает данные DMA, переводит счеты АЦП в напряжение, выполняет фильтрацию, управляет светодиодами, отправляет в очередь. | 50 мс | Высокий | Подготавливает данные для передачи по UART
| Передача данных по UART | Считывает значения, полученные из первой задачи и отправляет их по UART в заданном формате | 500 мс | Низкий | Считывает подготовленные первой задачей данные и передает их по UART
|===

=== Обеспечение точности не менее 0,01 В

Для того, чтобы обеспечить измерение напряжения с требуемой точностью, необходимо обеспечить корректную работу АЦП в непрерывном режиме с передачей данных через DMA.

Точность измерения напряжения определяется следующими факторами:

. Разрешение АЦП: Количество бит влияет на шаг квантования (latexmath:[ \Delta V])
. Опорное напряжение: Задает диапазон измерений
. Частота АЦП: Влияет на длительность выборки  преобразлования

==== Выбор параметров тактирования

Поскольку в требованиях к ПО не сказано, каким должно быть потребление ресурсов, было решено использовать внешний кварцевый генератор с частотой тактирования 8 МГц. Его будет достаточно для выполнения всех задач.

==== Выбор разрешения АЦП

В STM32F411RET6 АЦП поддерживает разрешения 6, 8, 10 и 12 бит. Формула расчета шага квантования:

[%center]
[latexmath]
++++
\Delta V = \frac{V_{ref}}{2^n},
++++

где latexmath:[V_{ref} = 3,3 V] - опорное напряжение;
   latexmath:[n] - разрядность АЦП.

Рассмотрим варианты квантования при различных разрешениях.

При latexmath:[n] = 8 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^8} = \frac{3,3}{256} = 12,891 mV
++++

При latexmath:[n] = 10 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{10}} = \frac{3,3}{1024} = 3,223 mV
++++

При latexmath:[n] = 12 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{12}} = \frac{3,3}{4096} = 0,806 mV
++++

Как можно заметить, 8 бит разрешения не достаточно для обеспечения требуемой точности. 10 бит хватает, но для обеспечения большей устойчивости к шумам следует выбрать разрешение *12 бит*, т.е. установить в регистре ADC_CR1 в поле RES биты 00.

==== Выбор времени преобразования АЦП

Время преобразования необходимо выбрать таким, чтобы оно было меньше заданного периода измерения, т.е. 50 мс.

Чем больше время преобразования, тем точнее преобразованное значение. Руководствуясь этим суждением, следует выбрать время преобразования, максимально близкое к 50 мс.

АЦП тактируется от шины APB2, частота которой в контексте данной задачи равна 8 МГц. В регистре ADC_CCR в поле ADCPRE настраивается значение предделителся частоты. Его минимальное значение составляет 2 (биты 00). Тогда, АЦП тактируется от частоты latexmath:[\frac{8 MHz}{2} = 4 MHz].

Время одного такта АЦП равно:

[%center]
[latexmath]
++++
T_{cycle} = \frac{1}{4 \cdot 10^6} = 0,25 μs.
++++

Время выборки АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{sample} = N_{sample} \cdot T_{cycle},
++++

где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0).

Время преобразования АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{conversion} = (N_{sample} + N_{resolution}) \cdot T_{cycle},
++++
где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0); latexmath:[N_{resolution}] - разрешение АЦП (было выбрано 12 бит).

Ниже рассчитаны различные значения времени преобразования в зависимости от количества циклов выборки.

[cols="^,^"]
.Расчет времени преобразования
|===
| latexmath:[N_{sample}] | latexmath:[T_{conversion}], мкс
| 3 | 3,75
| 15 | 6,75
| 28 | 10
| 56 | 17
| 84 | 24
| 112 | 31
| 144 | 39
| 480 | 123
|===

Выберем самое большое количество циклов, т.е. 480 (биты 111 в поле SMP0 регистра ADC_SMPR2).

=== Формула расчета напряжения

Для преобразования напряжения с переменного резистора в код по АЦП, расположенного на плате расширения, будет использоваться формула:

\$"VoltageValue" = ("AdcCodeValue" * ("MaxVoltage"-"MinVoltage")) / ("MaxAdcCode"-"MinAdcCode") + "Offset" = "AdcCodeValue" * "K" + "Offset",\$

где \$"AdcCodeValue"\$ - текущее измеренное значение кода с 12 битного АЦП;
\$"MaxVoltage" = 3,30 В\$ – максимальное значение напряжения, которое может быть установлено потенциометром;
\$"MinVoltage" = 0,00 В\$ – минимальное значение напряжения, которое может быть установлено потенциометром;
\$"MaxAdcCode" = 4095\$ - максимальное значение кода АЦП, оно соответвует MaxVoltage;
\$"MinAdcCode" = 1\$ - минимальное значение кода, оно соответвует MinVoltage;
\$"K" = 0,000806\$ \$"Offset" = 0,0008\$ - отклонение от нуля.

Значения \$"MaxVoltage"\$ и \$"MinVoltage"\$ можно измерить вольтметром, при крайних положениях потенциометра.

=== Цифровой фильтр

Согласно требованиям к ПО, к измеренному напряжению должен быть применен <<filter, цифровой фильтр>>.

Формула фильтра:

[%center]
[latexmath]
++++
\tau = \begin{cases} 
1 - e^{-\frac{dt}{RC}}, & RC > 0~\text{сек} \\
1, & RC \leq 0~\text{сек}
\end{cases} \\
FilteredValue = OldFiltered + (Value - OldValue) \cdot \tau
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

Данный фильтр представляет собой экспоненциальный сглаживающий фильтр, имитирующий поведение аналогового RC-фильтра. Он часто используется для того, чтобы подавлять шумы в измерениях напряжения и других сигналов. 

Данный фильтр применяется в <<task1, высокоприоритетной задаче>> операционной системы реального времени.

=== Использование USART для передачи измеренных значений

<<UART, Согласно требованиям к ПО>>, передача измеренного напряжения должна передаваться по Bluetooth в заданном формате: *"Напряжение: " X.XXX [Units]*. Однако, поскольку информация на Bluetooth модуль поступает через UART, было решено использовать обычный UART для передачи данных на компьютер.

Читаться данные будут с помощью программы https://micro-pi.ru/terminal-1-9b-работаем-com-портом/[Terminal 1.9]. Формат байта UART в рамках курсового проекта можно выбрать стандартным, поскольку никаких дополнительных условий в требованиях к ПО не упоминалось:

[NOTE]
*1 стартовый бит + 8 бит данных + 1 стоповый бит, без проверки четности, режим дискретизации 1/16*

Микроконтроллер STM32F411RET6 поддерживает несколько UART-модулей. в курсовом проекте решено использовать модуль UART2, поскольку на плате XNUCLEO-F411RE он аппаратно подключен к чипу CP2102, позволяющему передавать данные UART через USB на компьютер. В данном случае для UART используются пины *PA2 (RX)* и *PA3 (TX)*.

Также необходимо правильно выбрать скорость передачи данных. Она должна быть достаточной для того, чтобы успевать передавать данные, а также не должна иметь большую ошибку (между реальной скоростью и ожидаемой).

Существует несколько стандартных скоростей передачи данных: 9600 бод, 19200 бод, 38400 бод, 57600 бод, 115200 бод. Поскольку было решено передавать данные по UART раз в 100 мс, то большая скорость передачи данных не требуется.

Рассчитаем время передачи одной строки <<output_format, заданного формата>> (19 символов) по формуле:

[%center]
[latexmath]
++++
t_{transmit} = \frac{19 \cdot 10}{9600} = 19,79 ms.
++++

Как можно заметить, скорости 9600 бод вполне достаточно для того, чтобы передавать требуемую строку раз в 100 мс.

Скорость передачи данных в UART определяется значением, записанным в регистр *USART_BRR*. Это значение рассчитывается по следующей формуле:

[%center]
[latexmath]
++++
USARTDIV = \frac{f_{CLK}}{BaudRate \cdot 8 \cdot (2 - OVER8)},
++++

где latexmath:[f_{CLK}] - системная частота; +
latexmath:[BaudRate] - желаемая скорость передачи данных, бод; +
latexmath:[OVER8] - значение, записанное в поле OVER8 регистра USART_CR1 (режим дискретизации).

Чем больше скорость - тем меньше делитель *USARTDIV* и больше ошибка от округления значения, записываемого в регистр *USART_BRR*.

Рассчитаем значение, которое необходимо записать в регистр *USART_BRR*.

[%center]
[latexmath]
++++
USARTDIV = \frac{8000000}{16 \cdot 9600} = 52,08333.
++++

Целая часть - 52, дробная часть - 0,08333.

В поле *DIV_Mantissa* регистра *USART_BRR* записывается 52 (0x340), в поле *DIV_Fraction* записывается округленное до ближайшего целого значение дробной части, т.е. 1 (0x001). Итого в регистр *USART_BRR* требуется записать значение *0x341*.

Рассчитаем ошибку для этого значения. При этом записанный в регистр делитель равен:
latexmath:[USARTDIV = \frac{52 + 1}{16} = 52,0625]:

[%center]
[latexmath]
++++
Error = \left|\frac{V_{r} - V_{d}}{V_{d}}\right| \cdot 100 \%
= \left|\frac{(\frac{f_{CLK}}{16 \cdot 52,0625}) - 9600}{9600}\right| \cdot 100 \%
= \frac{9603,84 - 9600}{9600} \cdot 100 \%
= 0,04 \%.
++++

Таким образом, реально записанная в регистр *USART_BRR* скорость составляет 9603,84 бод, с ошибкой 0,04%.

=== Таблицы регистров для настройки

[[table_RCC]]
.Настройки регистров тактирования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.3+| RCC_CR | HSEON (16) | 1 | Включить тактирования от внешнего кварцевого генератора (8 МГц)
| HSERDY (17) | Зависит от готовности | Устанавливается в 1, когда генератор стабилен и готов к работе
| HSION (0) | 0 | Отключить внутренний генератор (16 МГц) после того, как HSE включится
| RCC_CFGR | SW (1 : 0) | 01 | Выбрать HSE в качестве системной частоты
.2+| RCC_AHB1ENR | GPIOAEN (0) | 1 | Подать тактирование на порт GPIOA
| DMA2EN (22) | 1 | Подать тактирование на контроллер DMA2
| RCC_APB1ENR | USART2EN (17) | 1 | Подать тактирование на USART2
| RCC_APB2ENR | ADC1EN (8) | 1 | Подать тактирование на АЦП
|===

[[table_GPIO]]
.Настройки регистров GPIO
|===
.3+| GPIOA_MODER | MODER0 (1 : 0) | 11 | Установить пин PA0 в режим аналогового входа (для АЦП)
| MODER2 (5 : 4) | 10 | Установить пин PA2 в режим альтернативной функции (для UART TX)
| MODER3 (7 : 6) | 10 | Установить пин PA2 в режим альтернативной функции (для UART RX)
|===

[[table_ADC]]
.Настройки регистров для АЦП в режиме непрерывного преобразования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
| ADC_CR1 | RES (25 : 24) | 00 | Установить разрядность АЦП (12 бит)
.3+| ADC_CR2 | EOCS (10) | 1 | Установить тип окончания преобразования: Бит Окончания преобразования EOC устанавливается после окончания преобразования для каждого канала
| CONT (1) | 1 | Установить режим непрерывного преобразования
| DMA (8) | 1 | Включить режим DMA
| ADC_SQR1 | L (3 : 0) | 0000 | Установить количество преобразований равным 1
| ADC_SQR3 | SQ1 (4 : 0) | 0000 | Выбрать канал 0 для измерения
| ADC_SMPR2 | SMP0 (2: 0) | 111 | Установить время преобразования на 480 циклов
.2+| ADC_CR2 | ADON (0) | 1 | Запуск АЦП
| SWSTART (30) | 1 | Начать преобразование
| ADC_DR | DATA (15 : 0) | Переменное | Используется для считывания преобразованных данных
|===

[[table_DMA]]
.Регистры для настройки DMA
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.8+| DMA_S0CR | CHSEL (27 : 25) | 000 | Выбор канала 0
| DIR (7 : 6) | 00 | Направление передачи данных: от периферии к памяти
| CIRC (8) | 1 | Циклический режим включен (т.к. непрерывное преобразование)
| MINC (10) | 0 | Отключить инкремент адреса памяти (для записи одного значения)
| PINC (9) | 0 | Отключить инкремент адреса периферии (т.к. адрес АЦП фиксирован)
| PSIZE (12 : 11) | 01 | Установить размер данных периферии 32 бит (поскольку АЦП 12-битный)
| MSIZE (14 : 13) | 01 | Установить размер данных памяти 32 бит
| EN (0) | 1 или 0 | Перед настройкой DMA бит установить в 0, после настройки запустить поток и установить бит в 1
| DMA_S0PAR | PAR (31 : 0) | Адрес регистра ADC_DR | Хранит адрес АЦП
| DMA_S0MA0R | MDA (31 : 0) | Адрес памяти, куда данные будут записываться | Хранит адрес памяти, куда сохраняется результат измерений
| DMA_S0NDTR | NDT (15 : 0) | Количество данных для передачи | Хранит количество передаваемых данных
| DMA_LIFCR | CTCIF0 (5) | 1 или 0 | Сбросить флаг завершения передачи DMA
| DMA_LISR | TCIF0 (5) | 1 или 0 | Ожидание завершения передачи DMA
|===

[[table_USART]]
.Регистры для настройки UART
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.5+| USART_CR1 | UE (13) | 1 | Включить UART
| TE (3) | 1 | Разрешить передачу
| M (12) | 0 | Установить формат передаваемого байта: 1 стартовый бит + 8 бит данных
| PCE (10) | 0 | Отключить четность
| OVER8 (15) | 0 | Установить дискретизацию 1/16
| USART_CR2 | STOP (13 : 12) | 00 | 1 стоп-бит
| USART_BRR | Все | (52 << 4) \| 1 | Скорость передачи 9600 бод
|===

== Архитектура

.Общая архитектура проекта
image::obschie.jpg[]

Общий порядок работы на диаграмме:

. Запуск: MeasurementTask через Execute(): void инициирует процесс;
. Измерение: IParameter выполняет измерение через Measure ();
. Фильтрация: IFilter фильтрирует данные, передаёт результат в IFilterNotifier и ILumin;
. Обработка: ILumin рассчитывает параметры освещённости;
. Форматирование: Usart2Data преобразует данные в строку;
. Передача: BluetoothTask отправляет данные по Usart.

.архитектура Bluetooth
image::Bluetooth.png[]

.архитектура Filter
image::Filter.jpg[]

.архитектура Parametr
image::Parametr.jpg[]
.архитектура PWM
image::PWM.png[]
